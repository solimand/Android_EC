/*
 * generated by Xtext
 */
package org.project.droolsDSL.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.generator.IFileSystemAccess
import org.project.droolsDSL.ddsl.Statement
import java.util.Map
import java.util.HashMap
import java.util.List
import java.util.ArrayList

import org.project.droolsDSL.ddsl.impl.ExpressionImpl
import org.project.droolsDSL.ddsl.impl.IntConstantImpl
import org.project.droolsDSL.ddsl.impl.FloatConstantImpl
import org.project.droolsDSL.ddsl.impl.PlusImpl
import org.project.droolsDSL.ddsl.impl.BoolConstantImpl
import org.project.droolsDSL.ddsl.ConditionRule
import org.project.droolsDSL.utils.Statement_Context
import org.project.droolsDSL.ddsl.impl.MinusImpl
import org.project.droolsDSL.ddsl.impl.MulOrDivImpl
import org.project.droolsDSL.ddsl.impl.OrImpl
import org.project.droolsDSL.ddsl.impl.AndImpl
import org.project.droolsDSL.ddsl.impl.EqualityImpl
import org.project.droolsDSL.ddsl.impl.ComparisonImpl
import org.project.droolsDSL.ddsl.impl.ReferenceImpl
import org.project.droolsDSL.ddsl.impl.NotImpl
import org.project.droolsDSL.ddsl.impl.ReferenceTypeImpl
import org.project.droolsDSL.ddsl.impl.FluentImpl
import org.project.droolsDSL.ddsl.impl.EventFeatureImpl
import org.project.droolsDSL.ddsl.InRule
import org.project.droolsDSL.ddsl.impl.InExprImpl
import org.project.droolsDSL.MyOutputConfigurationProvider

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
class DdslGenerator implements IGenerator {

	/** STRING*/
	public static final String MODEL_LIB_NAME_MVN = "Model_Lib-1.0.jar";
	public static final String PATH_SUPPORT_STRING = "C:\\Users\\Soli\\Desktop\\SUPPORT";	
	public static final String PATH_MAVEN_REPO_WIN_STRING = System.getProperty("user.home")+"\\.m2\\repository";
	public static final String PACKAGE_NAME = "com.gradle.application.medicalec";

	final String APPLICATION_NAME = "APPLICATION_NAME";
 
	var List<Statement_Context> statement_List= new ArrayList<Statement_Context>();
	var Map<Integer, String[]> allEventParams = new HashMap<Integer, String[]>();
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		statement_List.clear
		
		//Build Classes in Statement List 
		for (e: resource.allContents.toIterable.filter(typeof(Statement))){
			var List<String> fluents = new ArrayList<String>();
			fluents.clear
			
			var List<String> params = new ArrayList<String>();
			params.clear		
			
			var String eventNameTemp = "";
			eventNameTemp = e.event.eventName;
			
			if (e.event.param != null){
			for(p:e.event.param) {params.add(p.name)}}
				
			var Map <String, Object[]> fluentContextTemp = new HashMap<String, Object[]>()
			for (f:e.fluent) {
				
				var toValueTemp = f.valuePart
				
//				if time=0 --> NO TIME
				var InRule timeTemp =null
				if (f.timePart!=null){ timeTemp =f.timePart} 
				
				//if cond=null ---> NO CONDITION
				var ConditionRule condTemp = null
				if (f.condPart!=null){condTemp =f.condPart}
				
				var List<Object> contextTemp = new ArrayList<Object>();
				contextTemp.clear
				contextTemp.add(toValueTemp)
				contextTemp.add(timeTemp)
				contextTemp.add(condTemp)
				
				fluentContextTemp.put(f.name, contextTemp)
			}
			
			statement_List.add(new Statement_Context(eventNameTemp,params, fluentContextTemp))
		}

		// Move To The End
		
		/*Model */
		fsa.generateFile('''models/MainModel.java''', compileMain)
		
		/*Manifest */
		fsa.generateFile('''AndroidManifest.xml''', MyOutputConfigurationProvider::APP_GEN_OUTPUT,
			compileManifest
		)
		
		/*Java */
		fsa.generateFile('''src/com.gradle.application.medicalec/MainActivity.java''', MyOutputConfigurationProvider::APP_GEN_OUTPUT,
			compileMainJava
		)

		/*RES */
		fsa.generateFile('''res/values/styles.xml''', MyOutputConfigurationProvider::APP_GEN_OUTPUT,
			compileValueStyle
		)
		fsa.generateFile('''res/values/strings.xml''', MyOutputConfigurationProvider::APP_GEN_OUTPUT,
			compileValueString
		)
		fsa.generateFile('''res/values/dimens.xml''', MyOutputConfigurationProvider::APP_GEN_OUTPUT,
			compileValueDimens
		)
		fsa.generateFile('''res/layout/activity_main.xml''', MyOutputConfigurationProvider::APP_GEN_OUTPUT,
			compileLayoutActivityMain
		)
		fsa.generateFile('''res/layout/fragment_main_dummy.xml''', MyOutputConfigurationProvider::APP_GEN_OUTPUT,
			compileLayoutFragmentMainDummy
		)
		fsa.generateFile('''res/menu/main.xml''', MyOutputConfigurationProvider::APP_GEN_OUTPUT,
			compileMenuMain
		)
				
		/*GRADLE */
		fsa.generateFile('''build.gradle''', MyOutputConfigurationProvider::APP_GEN_OUTPUT,
			compileGradle
		)
		

	}

	/**_____Compile Method_____**/
	def compileMain() {
		'''
		package «PACKAGE_NAME»;
		//IMPORTs
		import it.bragaglia.freckles.model.*;
		import it.bragaglia.freckles.model.expressions.*;
		import it.bragaglia.freckles.model.expressions.operations.*;
		import it.bragaglia.freckles.model.conditions.*;
		import it.bragaglia.freckles.model.conditions.relations.*;
		
		import java.util.ArrayList;
		import java.util.HashMap;
		import java.util.List;
		import java.util.Map;
		
		public class MainModel {

			public static void main (String[] args) {
				
				Model model = new ModelImpl();
				
				/*
				public MainModel__Time(Model myGenModel){
					this.model=myGenModel;
				}
				*/

				ExpressionDescr exprContainer;
				ConditionDescr condContainer;
				Context contextContainer;
				Effect effectContainer;
				List<Effect> effects = new ArrayList<Effect>();

				«compileParams()»
				«FOR statementCurr: statement_List»
				
				// Statement «statement_List.indexOf(statementCurr)» proceed...
					«FOR f:statementCurr.fluents»
						«var ExpressionImpl exprImplTemp =  statementCurr.getExpression(f) as ExpressionImpl»
						«compileExpr(statementCurr.eventName, statement_List.indexOf(statementCurr), f, exprImplTemp)»
					«ENDFOR»
				// Statement «statement_List.indexOf(statementCurr)» Finish
				«ENDFOR»

				//System.out.println("Done.");
				
			}
«««			public static Model getModel(){
«««				return MainModel.model;
«««			}

		}
		
		'''
	}


/*________________________________________________________________________________________*/
	/**_____Parameter Instance_____**/
	def compileParams(){
		'''
		// Parameters MAP 
		
		Map<Integer, ParameterDescr[]> allEventParams = new HashMap<Integer, ParameterDescr[]>();
		«FOR statementCurr: statement_List»
			«IF statementCurr.params!=null»
				«allEventParams.put(statement_List.indexOf(statementCurr), statementCurr.params)»
				ParameterDescr paramsOfStatement_«statement_List.indexOf(statementCurr)»[] = new ParameterDescr[«statement_List.get(statement_List.indexOf(statementCurr)).params.length»];
				«FOR p: statement_List.get(statement_List.indexOf(statementCurr)).params»
						paramsOfStatement_«statement_List.indexOf(statementCurr)»[«statement_List.get(statement_List.indexOf(statementCurr)).params.indexOf(p)»] = new ParameterDescr("«p»");
				«ENDFOR»
				allEventParams.put(«statement_List.indexOf(statementCurr)», paramsOfStatement_«statement_List.indexOf(statementCurr)»);
				
			«ENDIF»
		«ENDFOR»
		'''
	}
	def int retrieveParam(int statementNum, String paramName){
		var paramNumTemp = 100
		for (s: allEventParams.get(statementNum)){
			if (s.equals(paramName))
				paramNumTemp = allEventParams.get(statementNum).indexOf(s)
		}				
		return paramNumTemp;
	}
	

/*________________________________________________________________________________________*/
	/**_____Simple Expression Case_____**/
	def dispatch compileTerminalRight(int statementNum, ExpressionImpl term){
		switch term{
			IntConstantImpl:{'''new NumberDescr(«term.value»)'''}
			FloatConstantImpl:{'''new NumberDescr(«term.value»)'''}
			BoolConstantImpl:{'''new NumberDescr(«term.value»)'''}
		}				
	}
	def dispatch compileTerminalLeft(int statementNum, ExpressionImpl term){
		switch term{
			IntConstantImpl:{'''new NumberDescr(«term.value»)'''}
			FloatConstantImpl:{'''new NumberDescr(«term.value»)'''}
			BoolConstantImpl:{'''new NumberDescr(«term.value»)'''}
		}				
	}
	def dispatch compileTerminalRight(int statementNum, ReferenceTypeImpl term){
		switch term{
			EventFeatureImpl:{
				'''
				paramsOfStatement_«statementNum»[«retrieveParam(statementNum,term.name)»]«
				»'''
			}
			FluentImpl:{
				'''
				new SampleDescr("«term.name»")
				'''
			}
		}				
	}
	def dispatch compileTerminalLeft(int statementNum, ReferenceTypeImpl term){
		switch term{
			EventFeatureImpl:{
				'''
				paramsOfStatement_«statementNum»[«retrieveParam(statementNum,term.name)»]«
				»'''
			}
			FluentImpl:{'''new SampleDescr(«term.name»)'''}
		}				
	}
	
/*________________________________________________________________________________________*/
	/** HARD Expression Case */		
	def dispatch compileRecExpr (String eventName, int statementNum, String fluentName, IntConstantImpl conditionExpr){
		'''new NumberDescr(«conditionExpr.value»)'''
	}
	def dispatch compileRecExpr (String eventName, int statementNum, String fluentName, FloatConstantImpl conditionExpr){
		'''new NumberDescr(«conditionExpr.value»)'''
	}
	def dispatch compileRecExpr (String eventName, int statementNum, String fluentName, BoolConstantImpl conditionExpr){
		'''new NumberDescr(«conditionExpr.value»)'''
	}
	def dispatch compileRecExpr (String eventName, int statementNum, String fluentName, ReferenceImpl conditionExpr){
		'''
		«IF conditionExpr.ref.eClass.name.contains("Feature")»
			paramsOfStatement_«statementNum»[«retrieveParam(statementNum,conditionExpr.ref.name)»]
		«ELSE»
			new SampleDescr("«conditionExpr.ref.name»")
		«ENDIF»
		'''
	}
	def dispatch compileRecExpr (String eventName, int statementNum, String fluentName, PlusImpl conditionExpr){
		'''
			«IF conditionExpr.left.eClass.name.contains("Constant") && conditionExpr.right.eClass.name.contains("Constant")»
				new PlusDescr( «compileTerminalLeft(statementNum,conditionExpr.left as ExpressionImpl)»,«
				»«compileTerminalLeft(statementNum,conditionExpr.right as ExpressionImpl)»)
			«ELSE»
				«IF conditionExpr.left.eClass.name.contains("Constant")»
					new PlusDescr(«compileTerminalLeft(statementNum,conditionExpr.left as ExpressionImpl)»,«
					»«compileRecExpr(eventName, statementNum,fluentName,conditionExpr.right as ExpressionImpl)»)
				«ENDIF»
				«IF !conditionExpr.left.eClass.name.contains("Constant")»
					new PlusDescr(«compileRecExpr(eventName, statementNum,fluentName,conditionExpr.left as ExpressionImpl)»,«
					»«compileRecExpr(eventName, statementNum,fluentName,conditionExpr.right as ExpressionImpl)»)«
				»«ENDIF»
			«ENDIF»
		'''	
	}
	def dispatch compileRecExpr (String eventName, int statementNum, String fluentName, MinusImpl conditionExpr){
		'''
			«IF conditionExpr.left.eClass.name.contains("Constant") && conditionExpr.right.eClass.name.contains("Constant")»
				new MinusDescr( «compileTerminalLeft(statementNum,conditionExpr.left as ExpressionImpl)»,«
				»«compileTerminalLeft(statementNum,conditionExpr.right as ExpressionImpl)»)
			«ELSE»
				«IF conditionExpr.left.eClass.name.contains("Constant")»
					new MinusDescr(«compileTerminalLeft(statementNum,conditionExpr.left as ExpressionImpl)»,«
					»«compileRecExpr(eventName, statementNum,fluentName,conditionExpr.right as ExpressionImpl)»)
				«ENDIF»
				«IF !conditionExpr.left.eClass.name.contains("Constant")»
					new MinusDescr(«compileRecExpr(eventName, statementNum,fluentName,conditionExpr.left as ExpressionImpl)»,«
					»«compileRecExpr(eventName, statementNum,fluentName,conditionExpr.right as ExpressionImpl)»)«
				»«ENDIF»
			«ENDIF»
		'''
	}
	def dispatch compileRecExpr (String eventName, int statementNum, String fluentName, MulOrDivImpl conditionExpr){
		'''
			«IF conditionExpr.op.equals("*")»
				«IF conditionExpr.left.eClass.name.contains("Constant") && conditionExpr.right.eClass.name.contains("Constant")»
					new TimesDescr( «compileTerminalLeft(statementNum,conditionExpr.left as ExpressionImpl)»,«
					»«compileTerminalLeft(statementNum,conditionExpr.right as ExpressionImpl)»)
				«ELSE»
					«IF conditionExpr.left.eClass.name.contains("Constant")»
						new TimesDescr(«compileTerminalLeft(statementNum,conditionExpr.left as ExpressionImpl)»,«
						»«compileRecExpr(eventName, statementNum,fluentName,conditionExpr.right as ExpressionImpl)»)
					«ENDIF»
					«IF !conditionExpr.left.eClass.name.contains("Constant")»
						new TimesDescr(«compileRecExpr(eventName, statementNum,fluentName,conditionExpr.left as ExpressionImpl)»,«
						»«compileRecExpr(eventName, statementNum,fluentName,conditionExpr.right as ExpressionImpl)»)«
					»«ENDIF»
				«ENDIF»
			«ELSE»
				«IF conditionExpr.left.eClass.name.contains("Constant") && conditionExpr.right.eClass.name.contains("Constant")»
					new ObelusDescr( «compileTerminalLeft(statementNum,conditionExpr.left as ExpressionImpl)»,«
					»«compileTerminalLeft(statementNum,conditionExpr.right as ExpressionImpl)»)
				«ELSE»
					«IF conditionExpr.left.eClass.name.contains("Constant")»
						new ObelusDescr(«compileTerminalLeft(statementNum,conditionExpr.left as ExpressionImpl)»,«
						»«compileRecExpr(eventName, statementNum,fluentName,conditionExpr.right as ExpressionImpl)»)
					«ENDIF»
					«IF !conditionExpr.left.eClass.name.contains("Constant")»
						new ObelusDescr(«compileRecExpr(eventName, statementNum,fluentName,conditionExpr.left as ExpressionImpl)»,«
						»«compileRecExpr(eventName, statementNum,fluentName,conditionExpr.right as ExpressionImpl)»)«
					»«ENDIF»
				«ENDIF»
			«ENDIF»
		'''
	}
	
	
	
/*________________________________________________________________________________________*/	
	/** FIRST compile call Case */	
	def /*dispatch*/ compileExpr (String eventName, int statementNum, String fluentName, ExpressionImpl conditionExpr){
		var espr = conditionExpr.expression
		switch espr{
			ReferenceImpl:{
				'''
				«IF espr.ref.eClass.name.contains("Feature")»
					exprContainer = paramsOfStatement_«statementNum»[«retrieveParam(statementNum,espr.ref.name)»];
					
					«IF statement_List.get(statementNum).getCondition(fluentName) != null»
						«compileCond(eventName,statementNum, fluentName, statement_List.get(statementNum).getCondition(fluentName) as ExpressionImpl)»
					«ELSE»
						«compileContextEffect(eventName, statementNum, fluentName, null)»
					«ENDIF»
				«ELSE»
					exprContainer = new SampleDescr("«espr.ref.name»");
					
					«IF statement_List.get(statementNum).getCondition(fluentName) != null»
						«compileCond(eventName,statementNum, fluentName, statement_List.get(statementNum).getCondition(fluentName) as ExpressionImpl)»
					«ELSE»
						«compileContextEffect(eventName, statementNum, fluentName, null)»
					«ENDIF»
				«ENDIF»				
				'''
			}
			IntConstantImpl:{
				'''
				exprContainer = new NumberDescr(«espr.value»);

				«IF statement_List.get(statementNum).getCondition(fluentName) != null»
					«compileCond(eventName,statementNum, fluentName, statement_List.get(statementNum).getCondition(fluentName) as ExpressionImpl)»
				«ELSE»
					«compileContextEffect(eventName, statementNum, fluentName, null)»
				«ENDIF»
				'''
			}
			FloatConstantImpl:{
				'''
				exprContainer = new NumberDescr(«espr.value»);
				
				«IF statement_List.get(statementNum).getCondition(fluentName) != null»
					«compileCond(eventName,statementNum, fluentName, statement_List.get(statementNum).getCondition(fluentName) as ExpressionImpl)»
				«ELSE»
					«compileContextEffect(eventName, statementNum, fluentName, null)»
				«ENDIF»
				'''
			}
			PlusImpl:{	
				'''
«««				Simple case 1+2				
				«IF espr.left.eClass.name.contains("Constant") && espr.right.eClass.name.contains("Constant")»

					exprContainer = new PlusDescr( «compileTerminalLeft(statementNum,espr.left as ExpressionImpl)»,«
						»«compileTerminalRight(statementNum,espr.right as ExpressionImpl)»);
				«ELSE»
«««					Case 1+(2+3)
					«IF espr.left.eClass.name.contains("Constant")»
						exprContainer = new PlusDescr(«compileTerminalLeft(statementNum,espr.left as ExpressionImpl)»,«
						»«compileRecExpr(eventName, statementNum,fluentName,espr.right as ExpressionImpl)»);
					«ENDIF»
«««					Case 1+2+3
					«IF !espr.left.eClass.name.contains("Constant")»
						exprContainer = new PlusDescr(«compileRecExpr(eventName, statementNum,fluentName,espr.left as ExpressionImpl)»,«
						»«compileRecExpr(eventName, statementNum,fluentName,espr.right as ExpressionImpl)»);
					«ENDIF»
				«ENDIF»
				
				«IF statement_List.get(statementNum).getCondition(fluentName) != null»
					«compileCond(eventName,statementNum, fluentName, statement_List.get(statementNum).getCondition(fluentName) as ExpressionImpl)»
				«ELSE»
					«IF statement_List.get(statementNum).getTime(fluentName) != null»
						«compileTime(eventName,statementNum,fluentName,statement_List.get(statementNum).getTime(fluentName) as InExprImpl)»
					«ELSE»
						«compileContextEffect(eventName, statementNum, fluentName, null)»
					«ENDIF»					
				«ENDIF»
				'''			
			}
			
			MinusImpl:{
				'''
				«IF espr.left.eClass.name.contains("Constant") && espr.right.eClass.name.contains("Constant")»

					exprContainer =  new MinusDescr( «compileTerminalLeft(statementNum,espr.left as ExpressionImpl)»,«
						»«compileTerminalRight(statementNum,espr.right as ExpressionImpl)»);
				«ELSE»
					«IF espr.left.eClass.name.contains("Constant")»
						exprContainer = new MinusDescr(«compileTerminalLeft(statementNum,espr.left as ExpressionImpl)»,«
						»«compileRecExpr(eventName, statementNum,fluentName,espr.right as ExpressionImpl)»);
					«ENDIF»
					«IF !espr.left.eClass.name.contains("Constant")»
						exprContainer = new MinusDescr(«compileRecExpr(eventName, statementNum,fluentName,espr.left as ExpressionImpl)»,«
						»«compileRecExpr(eventName, statementNum,fluentName,espr.right as ExpressionImpl)»);
					«ENDIF»
				«ENDIF»

				«IF statement_List.get(statementNum).getCondition(fluentName) != null»
					«compileCond(eventName,statementNum, fluentName, statement_List.get(statementNum).getCondition(fluentName) as ExpressionImpl)»
				«ELSE»
					«compileContextEffect(eventName, statementNum, fluentName, null)»
				«ENDIF»
				'''
			}

			MulOrDivImpl: {
				'''
				«IF espr.op.equals("*")»
					«IF espr.left.eClass.name.contains("Constant") && espr.right.eClass.name.contains("Constant")»

						exprContainer = new TimesDescr( «compileTerminalLeft(statementNum,espr.left as ExpressionImpl)»,«
							»«compileTerminalRight(statementNum,espr.right as ExpressionImpl)»);
					«ELSE»
						«IF espr.left.eClass.name.contains("Constant")»
							exprContainer = new TimesDescr(«compileTerminalLeft(statementNum,espr.left as ExpressionImpl)»,«
							»«compileRecExpr(eventName, statementNum,fluentName,espr.right as ExpressionImpl)»);
						«ENDIF»
						«IF !espr.left.eClass.name.contains("Constant")»
							exprContainer = new TimesDescr(«compileRecExpr(eventName, statementNum,fluentName,espr.left as ExpressionImpl)»,«
							»«compileRecExpr(eventName, statementNum,fluentName,espr.right as ExpressionImpl)»);
						«ENDIF»
					«ENDIF»
					
					«IF statement_List.get(statementNum).getCondition(fluentName) != null»
						«compileCond(eventName,statementNum, fluentName, statement_List.get(statementNum).getCondition(fluentName) as ExpressionImpl)»
					«ELSE»
						«compileContextEffect(eventName, statementNum, fluentName, null)»
					«ENDIF»
				«ELSE»
					«IF espr.left.eClass.name.contains("Constant") && espr.right.eClass.name.contains("Constant")»

						exprContainer = new ObelusDescr( «compileTerminalLeft(statementNum,espr.left as ExpressionImpl)»,«
							»«compileTerminalRight(statementNum,espr.right as ExpressionImpl)»);
					«ELSE»
						«IF espr.left.eClass.name.contains("Constant")»
							exprContainer = new ObelusDescr(«compileTerminalLeft(statementNum,espr.left as ExpressionImpl)»,«
							»«compileRecExpr(eventName, statementNum,fluentName,espr.right as ExpressionImpl)»);
						«ENDIF»
						«IF !espr.left.eClass.name.contains("Constant")»
							exprContainer = new ObelusDescr(«compileRecExpr(eventName, statementNum,fluentName,espr.left as ExpressionImpl)»,«
							»«compileRecExpr(eventName, statementNum,fluentName,espr.right as ExpressionImpl)»);
						«ENDIF»
					«ENDIF»
					
					«IF statement_List.get(statementNum).getCondition(fluentName) != null»
						«compileCond(eventName,statementNum, fluentName, statement_List.get(statementNum).getCondition(fluentName) as ExpressionImpl)»
					«ELSE»
						«compileContextEffect(eventName, statementNum, fluentName, null)»
					«ENDIF»					
				«ENDIF»
				'''
			}
			default: '''//default compileExpr «espr.eClass»'''
		}
	}//compileExpr

	def compileContextEffect (String eventName, int statementNum, String fluentName, String opCond){
		'''
		«IF opCond!=null»
				contextContainer = new ContextImpl(paramsOfStatement_«statementNum», exprContainer, condContainer );
		«ELSE»
				contextContainer = new ContextImpl(paramsOfStatement_«statementNum»,exprContainer , null);
		«ENDIF»
		
		effectContainer = new EffectImpl("«fluentName»", contextContainer);
			effects.add(effectContainer);
			
		model.add("«eventName»", (Effect[]) effects.toArray());
		effects.clear();
		 
		'''
	}

/*________________________________________________________________________________________*/	
	/**FIRST Time Compile */
	def compileTime (String eventName, int statementNum, String fluentName, InExprImpl conditionExpr){
		var time = conditionExpr.inTimeExpr
		'''compile TIME'''
	}
	

/*________________________________________________________________________________________*/	
	/**FIRST Condition Compile */
	def compileCond (String eventName, int statementNum, String fluentName, ExpressionImpl conditionExpr){
		var cond = conditionExpr.condition
		switch cond{
			NotImpl:{
				'''
				«IF cond.expression.eClass.name.equals("Constant")»
						condContainer = new NotDescr( «compileTerminalLeft(statementNum,cond.expression as ExpressionImpl)»);
				«ELSE»
						condContainer = new NotDescr(«compileRecExpr(eventName, statementNum,fluentName,cond.expression as ExpressionImpl)»);
				«ENDIF»
				
				«compileContextEffect(eventName,statementNum,fluentName, "Not")»
				'''
			}
			OrImpl:{
				'''
				«IF cond.left.eClass.name.contains("Constant") && cond.right.eClass.name.contains("Constant")»
					condContainer = new OrDescr( «compileTerminalLeft(statementNum,cond.left as ExpressionImpl)»,«
						»«compileTerminalRight(statementNum,cond.right as ExpressionImpl)»);
				«ELSE»
					«IF cond.left.eClass.name.contains("Constant")»
						condContainer = new OrDescr(«compileTerminalLeft(statementNum,cond.left as ExpressionImpl)»,«
						»«compileRecExpr(eventName, statementNum,fluentName,cond.right as ExpressionImpl)»);
					«ENDIF»
					«IF !cond.left.eClass.name.contains("Constant")»
						condContainer = new OrDescr(«compileRecExpr(eventName, statementNum,fluentName,cond.left as ExpressionImpl)»,«
						»«compileRecExpr(eventName, statementNum,fluentName,cond.right as ExpressionImpl)»);
					«ENDIF»
				«ENDIF»
				
				«compileContextEffect(eventName,statementNum,fluentName,"Or")»
				'''
			}
			AndImpl:{
				'''
				«IF cond.left.eClass.name.contains("Constant") && cond.right.eClass.name.contains("Constant")»
					condContainer = new AndDescr( «compileTerminalLeft(statementNum,cond.left as ExpressionImpl)»,«
						»«compileTerminalRight(statementNum,cond.right as ExpressionImpl)»);
				«ELSE»
					«IF cond.left.eClass.name.contains("Constant")»
						condContainer = new AndDescr(«compileTerminalLeft(statementNum,cond.left as ExpressionImpl)»,«
						»«compileRecExpr(eventName, statementNum,fluentName,cond.right as ExpressionImpl)»);
					«ENDIF»
					«IF !cond.left.eClass.name.contains("Constant")»
						condContainer = new AndDescr(«compileRecExpr(eventName, statementNum,fluentName,cond.left as ExpressionImpl)»,«
						»«compileRecExpr(eventName, statementNum,fluentName,cond.right as ExpressionImpl)»);
					«ENDIF»
				«ENDIF»
				
				«compileContextEffect(eventName,statementNum,fluentName,"And")»
				
				'''
			}
			EqualityImpl:{
				'''
				«IF cond.op.equals("==")»					««««==
					«IF cond.left.eClass.name.contains("Constant") && cond.right.eClass.name.contains("Constant")»
						condContainer = new SameDescr( «compileTerminalLeft(statementNum,cond.left as ExpressionImpl)»,«
							»«compileTerminalRight(statementNum,cond.right as ExpressionImpl)»);
					«ELSE»
						«IF cond.left.eClass.name.contains("Constant")»
							condContainer = new SameDescr(«compileTerminalLeft(statementNum,cond.left as ExpressionImpl)»,«
							»«compileRecExpr(eventName, statementNum,fluentName,cond.right as ExpressionImpl)»);
						«ENDIF»
						«IF !cond.left.eClass.name.contains("Constant")»
							condContainer = new SameDescr(«compileRecExpr(eventName, statementNum,fluentName,cond.left as ExpressionImpl)»,«
							»«compileRecExpr(eventName, statementNum,fluentName,cond.right as ExpressionImpl)»);
						«ENDIF»
					«ENDIF»
				
				«compileContextEffect(eventName,statementNum,fluentName,"Same")»
				«ELSE» 										««««!=
					«IF cond.left.eClass.name.contains("Constant") && cond.right.eClass.name.contains("Constant")»
						condContainer = new DifferentDescr( «compileTerminalLeft(statementNum,cond.left as ExpressionImpl)»,«
							»«compileTerminalRight(statementNum,cond.right as ExpressionImpl)»);
					«ELSE»
						«IF cond.left.eClass.name.contains("Constant")»
							condContainer = new DifferentDescr(«compileTerminalLeft(statementNum,cond.left as ExpressionImpl)»,«
							»«compileRecExpr(eventName, statementNum,fluentName,cond.right as ExpressionImpl)»);
						«ENDIF»
						«IF !cond.left.eClass.name.contains("Constant")»
							condContainer = new DifferentDescr(«compileRecExpr(eventName, statementNum,fluentName,cond.left as ExpressionImpl)»,«
							»«compileRecExpr(eventName, statementNum,fluentName,cond.right as ExpressionImpl)»);
						«ENDIF»
					«ENDIF»
				
				«compileContextEffect(eventName,statementNum,fluentName,"Different")»
				«ENDIF»
				'''
			}
			ComparisonImpl:{
				'''
				«IF cond.op.equals(">=")»					««««>=
					«IF cond.left.eClass.name.contains("Constant") && cond.right.eClass.name.contains("Constant")»
						condContainer = new MoreEqualsDescr( «compileTerminalLeft(statementNum,cond.left as ExpressionImpl)»,«
							»«compileTerminalRight(statementNum,cond.right as ExpressionImpl)»);
					«ELSE»
						«IF cond.left.eClass.name.contains("Constant")»
							condContainer = new MoreEqualsDescr(«compileTerminalLeft(statementNum,cond.left as ExpressionImpl)»,«
							»«compileRecExpr(eventName, statementNum,fluentName,cond.right as ExpressionImpl)»);
						«ENDIF»
						«IF !cond.left.eClass.name.contains("Constant")»
							condContainer = new MoreEqualsDescr(«compileRecExpr(eventName, statementNum,fluentName,cond.left as ExpressionImpl)»,«
							»«compileRecExpr(eventName, statementNum,fluentName,cond.right as ExpressionImpl)»);
						«ENDIF»
					«ENDIF»
				
				«compileContextEffect(eventName,statementNum,fluentName,"MoreEquals")»
				«ELSEIF cond.op.equals("<=")» 				««««<=
					«IF cond.left.eClass.name.contains("Constant") && cond.right.eClass.name.contains("Constant")»
						condContainer = new LessEqualsDescr( «compileTerminalLeft(statementNum,cond.left as ExpressionImpl)»,«
							»«compileTerminalRight(statementNum,cond.right as ExpressionImpl)»);
					«ELSE»
						«IF cond.left.eClass.name.contains("Constant")»
							condContainer = new LessEqualsDescr(«compileTerminalLeft(statementNum,cond.left as ExpressionImpl)»,«
							»«compileRecExpr(eventName, statementNum,fluentName,cond.right as ExpressionImpl)»);
						«ENDIF»
						«IF !cond.left.eClass.name.contains("Constant")»
							condContainer = new LessEqualsDescr(«compileRecExpr(eventName, statementNum,fluentName,cond.left as ExpressionImpl)»,«
							»«compileRecExpr(eventName, statementNum,fluentName,cond.right as ExpressionImpl)»);
						«ENDIF»
					«ENDIF»
				
				«compileContextEffect(eventName,statementNum,fluentName,"LessEquals")»
				«ELSEIF cond.op.equals(">")»				««««>
					«IF cond.left.eClass.name.contains("Constant") && cond.right.eClass.name.contains("Constant")»
						condContainer = new MoreDescr( «compileTerminalLeft(statementNum,cond.left as ExpressionImpl)»,«
							»«compileTerminalRight(statementNum,cond.right as ExpressionImpl)»);
					«ELSE»
						«IF cond.left.eClass.name.contains("Constant")»
							condContainer = new MoreDescr(«compileTerminalLeft(statementNum,cond.left as ExpressionImpl)»,«
							»«compileRecExpr(eventName, statementNum,fluentName,cond.right as ExpressionImpl)»);
						«ENDIF»
						«IF !cond.left.eClass.name.contains("Constant")»
							condContainer = new MoreDescr(«compileRecExpr(eventName, statementNum,fluentName,cond.left as ExpressionImpl)»,«
							»«compileRecExpr(eventName, statementNum,fluentName,cond.right as ExpressionImpl)»);
						«ENDIF»
					«ENDIF»
				
				«compileContextEffect(eventName,statementNum,fluentName,"More")»
				«ELSE» 										««««<
					«IF cond.left.eClass.name.contains("Constant") && cond.right.eClass.name.contains("Constant")»
						condContainer = new LessDescr( «compileTerminalLeft(statementNum,cond.left as ExpressionImpl)»,«
							»«compileTerminalRight(statementNum,cond.right as ExpressionImpl)»);
					«ELSE»
						«IF cond.left.eClass.name.contains("Constant")»
							condContainer = new LessDescr(«compileTerminalLeft(statementNum,cond.left as ExpressionImpl)»,«
							»«compileRecExpr(eventName, statementNum,fluentName,cond.right as ExpressionImpl)»);
						«ENDIF»
						«IF !cond.left.eClass.name.contains("Constant")»
							condContainer = new LessDescr(«compileRecExpr(eventName, statementNum,fluentName,cond.left as ExpressionImpl)»,«
							»«compileRecExpr(eventName, statementNum,fluentName,cond.right as ExpressionImpl)»);
						«ENDIF»
					«ENDIF»
				
				«compileContextEffect(eventName,statementNum,fluentName,"Less")»
				«ENDIF»
				'''
			}
			default: '''//default compileCond'''
		}
	}

/*________________________________________________________________________________________*/
	/** HARD Condition Case */
	def dispatch compileRecExpr (String eventName, int statementNum, String fluentName, NotImpl conditionExpr){
		'''
		«IF conditionExpr.expression.eClass.name.contains("Constant")»
			new NotDescr( «compileTerminalLeft(statementNum,conditionExpr.expression as ExpressionImpl)»)
		«ELSE»
			new NotDescr(«compileRecExpr(eventName, statementNum,fluentName,conditionExpr.expression as ExpressionImpl)»)
		«ENDIF»
		'''
	}
	def dispatch compileRecExpr (String eventName, int statementNum, String fluentName, OrImpl conditionExpr){
		'''
		«IF conditionExpr.left.eClass.name.contains("Constant") && conditionExpr.right.eClass.name.contains("Constant")»
			new OrDescr( «compileTerminalLeft(statementNum,conditionExpr.left as ExpressionImpl)»,«
			»«compileTerminalLeft(statementNum,conditionExpr.right as ExpressionImpl)»)
		«ELSE»
			«IF conditionExpr.left.eClass.name.contains("Constant")»
				new OrDescr(«compileTerminalLeft(statementNum,conditionExpr.left as ExpressionImpl)»,«
				»«compileRecExpr(eventName, statementNum,fluentName,conditionExpr.right as ExpressionImpl)»)
			«ENDIF»
			«IF !conditionExpr.left.eClass.name.contains("Constant")»
				new OrDescr(«compileRecExpr(eventName, statementNum,fluentName,conditionExpr.left as ExpressionImpl)»,«
				»«compileRecExpr(eventName, statementNum,fluentName,conditionExpr.right as ExpressionImpl)»)«
			»«ENDIF»
		«ENDIF»
		'''
	}
	def dispatch compileRecExpr (String eventName, int statementNum, String fluentName, AndImpl conditionExpr){
		'''
		«IF conditionExpr.left.eClass.name.contains("Constant") && conditionExpr.right.eClass.name.contains("Constant")»
			new AndDescr( «compileTerminalLeft(statementNum,conditionExpr.left as ExpressionImpl)»,«
			»«compileTerminalLeft(statementNum,conditionExpr.right as ExpressionImpl)»)
		«ELSE»
			«IF conditionExpr.left.eClass.name.contains("Constant")»
				new AndDescr(«compileTerminalLeft(statementNum,conditionExpr.left as ExpressionImpl)»,«
				»«compileRecExpr(eventName, statementNum,fluentName,conditionExpr.right as ExpressionImpl)»)
			«ENDIF»
			«IF !conditionExpr.left.eClass.name.contains("Constant")»
				new AndDescr(«compileRecExpr(eventName, statementNum,fluentName,conditionExpr.left as ExpressionImpl)»,«
				»«compileRecExpr(eventName, statementNum,fluentName,conditionExpr.right as ExpressionImpl)»)«
			»«ENDIF»
		«ENDIF»
		'''
	}
	def dispatch compileRecExpr (String eventName, int statementNum, String fluentName, EqualityImpl conditionExpr){
		'''
		«IF conditionExpr.op.equals("==")»						««««==
			«IF conditionExpr.left.eClass.name.contains("Constant") && conditionExpr.right.eClass.name.contains("Constant")»
				new SameDescr( «compileTerminalLeft(statementNum,conditionExpr.left as ExpressionImpl)»,«
				»«compileTerminalLeft(statementNum,conditionExpr.right as ExpressionImpl)»)
			«ELSE»
				«IF conditionExpr.left.eClass.name.contains("Constant")»
					new SameDescr(«compileTerminalLeft(statementNum,conditionExpr.left as ExpressionImpl)»,«
					»«compileRecExpr(eventName, statementNum,fluentName,conditionExpr.right as ExpressionImpl)»)
				«ENDIF»
				«IF !conditionExpr.left.eClass.name.contains("Constant")»
					new SameDescr(«compileRecExpr(eventName, statementNum,fluentName,conditionExpr.left as ExpressionImpl)»,«
					»«compileRecExpr(eventName, statementNum,fluentName,conditionExpr.right as ExpressionImpl)»)«
				»«ENDIF»
			«ENDIF»
		«ELSEIF conditionExpr.op.equals("!=")»					««««!=
			«IF conditionExpr.left.eClass.name.contains("Constant") && conditionExpr.right.eClass.name.contains("Constant")»
				new DifferentDescr( «compileTerminalLeft(statementNum,conditionExpr.left as ExpressionImpl)»,«
				»«compileTerminalLeft(statementNum,conditionExpr.right as ExpressionImpl)»)
			«ELSE»
				«IF conditionExpr.left.eClass.name.contains("Constant")»
					new DifferentDescr(«compileTerminalLeft(statementNum,conditionExpr.left as ExpressionImpl)»,«
					»«compileRecExpr(eventName, statementNum,fluentName,conditionExpr.right as ExpressionImpl)»)
				«ENDIF»
				«IF !conditionExpr.left.eClass.name.contains("Constant")»
					new DifferentDescr(«compileRecExpr(eventName, statementNum,fluentName,conditionExpr.left as ExpressionImpl)»,«
					»«compileRecExpr(eventName, statementNum,fluentName,conditionExpr.right as ExpressionImpl)»)«
				»«ENDIF»
			«ENDIF»
		«ENDIF»
		'''
	}
	def dispatch compileRecExpr (String eventName, int statementNum, String fluentName, ComparisonImpl conditionExpr){
		'''
		«IF conditionExpr.op.equals(">=")»						««««>=
			«IF conditionExpr.left.eClass.name.contains("Constant") && conditionExpr.right.eClass.name.contains("Constant")»
				new MoreEqualsDescr( «compileTerminalLeft(statementNum,conditionExpr.left as ExpressionImpl)»,«
				»«compileTerminalLeft(statementNum,conditionExpr.right as ExpressionImpl)»)
			«ELSE»
				«IF conditionExpr.left.eClass.name.contains("Constant")»
					new MoreEqualsDescr(«compileTerminalLeft(statementNum,conditionExpr.left as ExpressionImpl)»,
					«compileRecExpr(eventName, statementNum,fluentName,conditionExpr.right as ExpressionImpl)»)
				«ENDIF»
				«IF !conditionExpr.left.eClass.name.contains("Constant")»
					new MoreEqualsDescr(«compileRecExpr(eventName, statementNum,fluentName,conditionExpr.left as ExpressionImpl)»,
					«compileRecExpr(eventName, statementNum,fluentName,conditionExpr.right as ExpressionImpl)»)«
				»«ENDIF»
			«ENDIF»
		«ELSEIF conditionExpr.op.equals("<=")»					««««<=
			«IF conditionExpr.left.eClass.name.contains("Constant") && conditionExpr.right.eClass.name.contains("Constant")»
				new LessEqualsDescr( «compileTerminalLeft(statementNum,conditionExpr.left as ExpressionImpl)»,«
				»«compileTerminalLeft(statementNum,conditionExpr.right as ExpressionImpl)»)
			«ELSE»
				«IF conditionExpr.left.eClass.name.contains("Constant")»
					new LessEqualsDescr(«compileTerminalLeft(statementNum,conditionExpr.left as ExpressionImpl)»,
					«compileRecExpr(eventName, statementNum,fluentName,conditionExpr.right as ExpressionImpl)»)
				«ENDIF»
				«IF !conditionExpr.left.eClass.name.contains("Constant")»
					new LessEqualsDescr(«compileRecExpr(eventName, statementNum,fluentName,conditionExpr.left as ExpressionImpl)»,
					«compileRecExpr(eventName, statementNum,fluentName,conditionExpr.right as ExpressionImpl)»)«
				»«ENDIF»
			«ENDIF»
		«ELSEIF conditionExpr.op.equals(">")»					««««>
			«IF conditionExpr.left.eClass.name.contains("Constant") && conditionExpr.right.eClass.name.contains("Constant")»
				new MoreDescr( «compileTerminalLeft(statementNum,conditionExpr.left as ExpressionImpl)»,«
				»«compileTerminalLeft(statementNum,conditionExpr.right as ExpressionImpl)»)
			«ELSE»
				«IF conditionExpr.left.eClass.name.contains("Constant")»
					new MoreDescr(«compileTerminalLeft(statementNum,conditionExpr.left as ExpressionImpl)»,
					«compileRecExpr(eventName, statementNum,fluentName,conditionExpr.right as ExpressionImpl)»)
				«ENDIF»
				«IF !conditionExpr.left.eClass.name.contains("Constant")»
					new MoreDescr(«compileRecExpr(eventName, statementNum,fluentName,conditionExpr.left as ExpressionImpl)»,
					«compileRecExpr(eventName, statementNum,fluentName,conditionExpr.right as ExpressionImpl)»)«
				»«ENDIF»
			«ENDIF»
		«ELSE»													««««<
			«IF conditionExpr.left.eClass.name.contains("Constant") && conditionExpr.right.eClass.name.contains("Constant")»
				new LessDescr( «compileTerminalLeft(statementNum,conditionExpr.left as ExpressionImpl)»,«
				»«compileTerminalLeft(statementNum,conditionExpr.right as ExpressionImpl)»)
			«ELSE»
				«IF conditionExpr.left.eClass.name.contains("Constant")»
					new LessDescr(«compileTerminalLeft(statementNum,conditionExpr.left as ExpressionImpl)»,
					«compileRecExpr(eventName, statementNum,fluentName,conditionExpr.right as ExpressionImpl)»)
				«ENDIF»
				«IF !conditionExpr.left.eClass.name.contains("Constant")»
					new LessDescr(«compileRecExpr(eventName, statementNum,fluentName,conditionExpr.left as ExpressionImpl)»,
					«compileRecExpr(eventName, statementNum,fluentName,conditionExpr.right as ExpressionImpl)»)«
				»«ENDIF»
			«ENDIF»
		«ENDIF»
		'''
	}
	
/*________________________________________________________________________________________*/
	/** Compile Gradle */
	def compileGradle (/*String [] params*/){
		'''
		buildscript {
		    repositories {
		        mavenCentral()
		    }
		    dependencies {
		        classpath 'com.android.tools.build:gradle:0.5.+'
		    }
		}
		apply plugin: 'android'
		repositories {
		    mavenCentral()
		    mavenLocal()
		}
		 
		dependencies {
		    compile('it.bragaglia.freckles:Model_Lib:1.0')
		    compile('com.example.android:Android_Support_Lib:4.0')
		}
		
		
		//dependencies {
		//    compile fileTree(dir: 'libs', include: '*.jar')
		//}
		
		android {
		    compileSdkVersion 19
		    buildToolsVersion "19.0.0"
		
		    sourceSets {
		        main {
		            manifest.srcFile 'AndroidManifest.xml'
		            java.srcDirs = ['src']
		            resources.srcDirs = ['src']
		            aidl.srcDirs = ['src']
		            renderscript.srcDirs = ['src']
		            res.srcDirs = ['res']
		            assets.srcDirs = ['assets']
		        }
		
		        instrumentTest.setRoot('tests')
		
		        debug.setRoot('build-types/debug')
		        release.setRoot('build-types/release')
		    }
		}
		
		'''
	}
			
/*________________________________________________________________________________________*/
	/** Compile MANIFEST */
	def compileManifest (/*String [] params*/){
		'''
		<?xml version="1.0" encoding="utf-8"?>
		<manifest xmlns:android="http://schemas.android.com/apk/res/android"
		    package="com.gradle.application.medicalec"
		    android:versionCode="1"
		    android:versionName="1.0" >
		
		    <uses-sdk
		        android:minSdkVersion="14"
		        android:targetSdkVersion="19" />
		
		    <application
		        android:allowBackup="true"
		        android:icon="@drawable/ic_launcher"
		        android:label="«APPLICATION_NAME»"
		        android:theme="@style/AppTheme" 
		        android:debuggable="true">
		        <activity
		            android:name="com.gradle.application.medicalec.MainActivity"
		            android:label="«APPLICATION_NAME»" >
		            <intent-filter>
		                <action android:name="android.intent.action.MAIN" />
		
		                <category android:name="android.intent.category.LAUNCHER" />
		            </intent-filter>
		        </activity>
		    </application>
		
		</manifest>
				
		'''
	}

/*________________________________________________________________________________________*/
	/** Compile RES */
	def compileValueStyle (/*String [] params*/){
		'''
		<resources>

		    <!--
		        Base application theme, dependent on API level. This theme is replaced
		        by AppBaseTheme from res/values-vXX/styles.xml on newer devices.
		    -->
		    <style name="AppBaseTheme" parent="android:Theme.Light">
		        <!--
		            Theme customizations available in newer API levels can go in
		            res/values-vXX/styles.xml, while customizations related to
		            backward-compatibility can go here.
		        -->
		    </style>
		
		    <!-- Application theme. -->
		    <style name="AppTheme" parent="AppBaseTheme">
		        <!-- All customizations that are NOT specific to a particular API-level can go here. -->
		    </style>
		
		</resources>
		
		'''
	}
	
	def compileValueString (){
		'''
		<?xml version="1.0" encoding="utf-8"?>
		<resources>		
		    <string name="app_name">MedicalEC</string>
		    <string name="action_settings">Settings</string>
		    <string name="title_section1">Section 1</string>
		    <string name="title_section2">Section 2</string>
		    <string name="title_section3">Section 3</string>		
		</resources>
		
		'''
	}
	
	def compileValueDimens (){
		'''
		<resources>
		    <!-- Default screen margins, per the Android Design guidelines. -->
		    <dimen name="activity_horizontal_margin">16dp</dimen>
		    <dimen name="activity_vertical_margin">16dp</dimen>		
		</resources>
		
		'''
	}
	
	def compileLayoutActivityMain (){
		'''
		<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
		    xmlns:tools="http://schemas.android.com/tools"
		    android:id="@+id/container"
		    android:layout_width="match_parent"
		    android:layout_height="match_parent"
		    tools:context=".MainActivity"
		    tools:ignore="MergeRootFrame" />
		    
		'''
	}
	
	def compileLayoutFragmentMainDummy (){
		'''
		<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
		    xmlns:tools="http://schemas.android.com/tools"
		    android:layout_width="match_parent"
		    android:layout_height="match_parent"
		    android:paddingBottom="@dimen/activity_vertical_margin"
		    android:paddingLeft="@dimen/activity_horizontal_margin"
		    android:paddingRight="@dimen/activity_horizontal_margin"
		    android:paddingTop="@dimen/activity_vertical_margin"
		    tools:context=".MainActivity$DummySectionFragment" >
		
		    <TextView
		        android:id="@+id/section_label"
		        android:layout_width="wrap_content"
		        android:layout_height="wrap_content" />
		
		</RelativeLayout>
		
		'''
	}
	def compileMenuMain (){
		'''
		<menu xmlns:android="http://schemas.android.com/apk/res/android" >

		    <item
		        android:id="@+id/action_settings"
		        android:orderInCategory="100"
		        android:showAsAction="never"
		        android:title="@string/action_settings"/>
		
		</menu>
		
		'''
	}
	
	
/*________________________________________________________________________________________*/
	/** Compile JAVA */
	def compileMainJava(){
		'''
		package com.gradle.application.medicalec;

		import android.app.ActionBar;
		import android.os.Bundle;
		
		import android.support.v4.app.Fragment;
		import android.support.v4.app.FragmentActivity;
		import android.support.v4.app.NavUtils;
		import android.view.Gravity;
		import android.view.LayoutInflater;
		import android.view.Menu;
		import android.view.MenuItem;
		import android.view.View;
		import android.view.ViewGroup;
		import android.widget.ArrayAdapter;
		import android.widget.TextView;
		
		public class MainActivity extends FragmentActivity implements
				ActionBar.OnNavigationListener {
		
			/**
			 * The serialization (saved instance state) Bundle key representing the
			 * current dropdown position.
			 */
			private static final String STATE_SELECTED_NAVIGATION_ITEM = "selected_navigation_item";
		
			@Override
			protected void onCreate(Bundle savedInstanceState) {
				super.onCreate(savedInstanceState);
				setContentView(R.layout.activity_main);
		
				//Proj Var
				final Model myModel = null;
		
				// Set up the action bar to show a dropdown list.
				final ActionBar actionBar = getActionBar();
				actionBar.setDisplayShowTitleEnabled(false);
				actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_LIST);
		
				// Set up the dropdown list navigation in the action bar.
				actionBar.setListNavigationCallbacks(
				// Specify a SpinnerAdapter to populate the dropdown list.
						new ArrayAdapter<String>(actionBar.getThemedContext(),
								android.R.layout.simple_list_item_1,
								android.R.id.text1, new String[] {
										getString(R.string.title_section1),
										getString(R.string.title_section2),
										getString(R.string.title_section3), }), this);
			}
		
			@Override
			public void onRestoreInstanceState(Bundle savedInstanceState) {
				// Restore the previously serialized current dropdown position.
				if (savedInstanceState.containsKey(STATE_SELECTED_NAVIGATION_ITEM)) {
					getActionBar().setSelectedNavigationItem(
							savedInstanceState.getInt(STATE_SELECTED_NAVIGATION_ITEM));
				}
			}
		
			@Override
			public void onSaveInstanceState(Bundle outState) {
				// Serialize the current dropdown position.
				outState.putInt(STATE_SELECTED_NAVIGATION_ITEM, getActionBar()
						.getSelectedNavigationIndex());
			}
		
			@Override
			public boolean onCreateOptionsMenu(Menu menu) {
				// Inflate the menu; this adds items to the action bar if it is present.
				getMenuInflater().inflate(R.menu.main, menu);
				return true;
			}
		
			@Override
			public boolean onNavigationItemSelected(int position, long id) {
				// When the given dropdown item is selected, show its contents in the
				// container view.
				Fragment fragment = new DummySectionFragment();
				Bundle args = new Bundle();
				args.putInt(DummySectionFragment.ARG_SECTION_NUMBER, position + 1);
				fragment.setArguments(args);
				getSupportFragmentManager().beginTransaction()
						.replace(R.id.container, fragment).commit();
				return true;
			}
		
			/**
			 * A dummy fragment representing a section of the app, but that simply
			 * displays dummy text.
			 */
			public static class DummySectionFragment extends Fragment {
				/**
				 * The fragment argument representing the section number for this
				 * fragment.
				 */
				public static final String ARG_SECTION_NUMBER = "section_number";
		
				public DummySectionFragment() {
				}
		
				@Override
				public View onCreateView(LayoutInflater inflater, ViewGroup container,
						Bundle savedInstanceState) {
					View rootView = inflater.inflate(R.layout.fragment_main_dummy,
							container, false);
					TextView dummyTextView = (TextView) rootView
							.findViewById(R.id.section_label);
					dummyTextView.setText(Integer.toString(getArguments().getInt(
							ARG_SECTION_NUMBER)));
					return rootView;
				}
			}
		
		}

		'''
	}
}


	
/**
 * 
 * ALL Expression Type -->
 * 
 */
//			switch expr{
//				Plus:{}
//				IntConstant:{compileExpr(expr)}
//				BoolConstant:{'''//some1'''}
//				FloatConstant:{'''//some2'''}
//				And:{'''//some3'''}
//				Or:{'''//some3.1'''}			
//				Equality:{'''//some4'''}
//				Comparison:{'''//some5'''}
//				Minus:{'''//some6'''}
//				MulOrDiv:{'''//some7'''}
//				Not:{'''//some8'''}
//				FeatureRef: {'''//some9'''}
//				default: compileExpr(expr as IntConstant)
//			}//Switch